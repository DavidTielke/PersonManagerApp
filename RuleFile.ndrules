<?xml version="1.0" encoding="utf-8"?>
<Queries>
  <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Zu großen Klassen</Name>
warnif count > 0 

from t in JustMyCode.Types
where t.NbLinesOfCode > 2 || t.NbMethods > 10

select new { t, t.NbLinesOfCode, t.NbMethods }]]></Query>
  <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Zugroße oder komplexe Methoden</Name>
warnif count > 0 

from m in JustMyCode.Methods

where !m.IsPropertyGetter && !m.IsPropertySetter
   && !m.IsConstructor && !m.IsStatic

   && (m.NbLinesOfCode > 2 || m.CyclomaticComplexity > 7)

select new { m.Parent, m, m.NbLinesOfCode, m.CyclomaticComplexity, Severity = Severity.Info, Debt = 10.ToMinutes().ToDebt() }]]></Query>
  <Group Name="Namensmuster" Active="True" ShownInReport="False">
    <Group Name="Klassen" Active="True" ShownInReport="False">
      <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Alle Klassen sind Musterkonsistent</Name>
warnif count > 0 

let patternCatalogue = new string[]
{
  "Manager",
  "Repository",
  "Parser",
  "Reader",
  "DisplayCommands",
  "Initializer",

  "Program"
}

let managementClasses = JustMyCode.Types.Where(t => !t.ParentNamespace.FullName.Contains(".DataClasses")
                                                 && !t.IsGeneratedByCompiler)

from t in managementClasses

where !patternCatalogue.Any(pn => t.SimpleName.EndsWith(pn))

select new { t, Severity = Severity.Blocker }]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Namensmuster "Manager"</Name>
warnif count > 0 

let pattern = "Manager"

let allowedMethods = new string[]
{
  "Add",
  "Remove",
  "Update"
}

let allowedPrefixes = new string[]
{
  "Get",
  "Is",
  "Are"
}

let managementClasses = JustMyCode.Types.Where(t => !t.ParentNamespace.FullName.Contains(".DataClasses")
                                                 && !t.IsGeneratedByCompiler && t.SimpleName.EndsWith(pattern))

from t in managementClasses

let illegalMethods = t.Methods.Where(m => !allowedMethods.Any(am => m.SimpleName == am)
                                        && !allowedPrefixes.Any(ap => m.SimpleName.StartsWith(ap)))

where illegalMethods.Any()

select new { t, illegalMethods  }]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Namensmuster "Repository"</Name>
warnif count > 0 

let pattern = "Repository"

let allowedMethods = new string[]
{
  "Insert",
  "Delete",
  "Update",
  "Load"
}

let allowedPrefixes = new string[]
{

}

let managementClasses = JustMyCode.Types.Where(t => !t.ParentNamespace.FullName.Contains(".DataClasses")
                                                 && !t.IsGeneratedByCompiler && t.SimpleName.EndsWith(pattern))

from t in managementClasses

let illegalMethods = t.Methods.Where(m => !allowedMethods.Any(am => m.SimpleName == am)
                                        && !allowedPrefixes.Any(ap => m.SimpleName.StartsWith(ap)))

where illegalMethods.Any()

select new { t, illegalMethods  }
]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Namensmuster "Parser"</Name>
warnif count > 0 

let pattern = "Parser"

let allowedMethods = new string[]
{
  "Parse"
}

let allowedPrefixes = new string[]
{

}

let managementClasses = JustMyCode.Types.Where(t => !t.ParentNamespace.FullName.Contains(".DataClasses")
                                                 && !t.IsGeneratedByCompiler && t.SimpleName.EndsWith(pattern))

from t in managementClasses

let illegalMethods = t.Methods.Where(m => !allowedMethods.Any(am => m.SimpleName == am)
                                        && !allowedPrefixes.Any(ap => m.SimpleName.StartsWith(ap)))

where illegalMethods.Any()

select new { t, illegalMethods  }
]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Namensmuster "Reader"</Name>
warnif count > 0 

let pattern = "Reader"

let allowedMethods = new string[]
{

}

let allowedPrefixes = new string[]
{
  "Read"
}

let managementClasses = JustMyCode.Types.Where(t => !t.ParentNamespace.FullName.Contains(".DataClasses")
                                                 && !t.IsGeneratedByCompiler && t.SimpleName.EndsWith(pattern))

from t in managementClasses

let illegalMethods = t.Methods.Where(m => !allowedMethods.Any(am => m.SimpleName == am)
                                        && !allowedPrefixes.Any(ap => m.SimpleName.StartsWith(ap)))

where illegalMethods.Any()

select new { t, illegalMethods  }
]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Namensmuster "DisplayCommands"</Name>
warnif count > 0 

let pattern = "DisplayCommands"

let allowedMethods = new string[]
{

}

let allowedPrefixes = new string[]
{
  "Display"
}

let managementClasses = JustMyCode.Types.Where(t => !t.ParentNamespace.FullName.Contains(".DataClasses")
                                                 && !t.IsGeneratedByCompiler && t.SimpleName.EndsWith(pattern))

from t in managementClasses

let illegalMethods = t.Methods.Where(m => !allowedMethods.Any(am => m.SimpleName == am)
                                        && !allowedPrefixes.Any(ap => m.SimpleName.StartsWith(ap)))

where illegalMethods.Any()

select new { t, illegalMethods  }
]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Namensmuster "Initializer"</Name>
warnif count > 0 

let pattern = "Initializer"

let allowedMethods = new string[]
{
  "Initialize",

}

let allowedPrefixes = new string[]
{

}

let managementClasses = JustMyCode.Types.Where(t => !t.ParentNamespace.FullName.Contains(".DataClasses")
                                                 && !t.IsGeneratedByCompiler && t.SimpleName.EndsWith(pattern))

from t in managementClasses

let illegalMethods = t.Methods.Where(m => !allowedMethods.Any(am => m.SimpleName == am)
                                        && !allowedPrefixes.Any(ap => m.SimpleName.StartsWith(ap)))

where illegalMethods.Any()

select new { t, illegalMethods  }
]]></Query>
    </Group>
    <Group Name="Komponenten" Active="True" ShownInReport="False">
      <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Alle Komponenten sind Musterkonsistent</Name>
warnif count > 0 

let patternCatalogue = new string[]
{
  "Client",
  "Storing",
  "Management",

  "DataClasses"
}

let components = JustMyCode.Assemblies

from t in components 

where !patternCatalogue.Any(pn => t.SimpleName.EndsWith(pn))

select new { t, Severity = Severity.Blocker }
]]></Query>
    </Group>
  </Group>
  <Group Name="DataClasses" Active="True" ShownInReport="False">
    <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Datenklassen hat keine Methoden</Name>

let dataClasses = JustMyCode.Types.Where(t => t.ParentNamespace.FullName.Contains(".DataClasses"))

from t in dataClasses

let methods = t.Methods.Where(m => !m.IsPropertyGetter && !m.IsPropertySetter)

where methods.Any()

select new { t, methods  }]]></Query>
    <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Datenklassen haben nur std. ctor</Name>

let dataClasses = JustMyCode.Types.Where(t => t.ParentNamespace.FullName.Contains(".DataClasses"))

from t in dataClasses

let illegalConstructors = t.Constructors.Where(c => c.NbParameters > 0)

select new { t, illegalConstructors }

]]></Query>
    <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Datenklassen referenzieren nur Datenklassen</Name>

let dataClasses = JustMyCode.Types.Where(t => t.ParentNamespace.FullName.Contains(".DataClasses"))

from t in dataClasses

let illegalTypes = t.TypesUsed.Where(tu => !tu.IsThirdParty && !tu.ParentNamespace.FullName.Contains(".DataClasses"))

where illegalTypes.Any()

select new { t, illegalTypes }

]]></Query>
  </Group>
  <Group Name="Namespaces" Active="True" ShownInReport="False">
    <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Korrekte Namespace Prefixe</Name>
warnif count > 0 

let namespaces = JustMyCode.Namespaces

let allowedPrefixes = new string[]
{
 "DavidTielke.PMA.CrossCutting",
 "DavidTielke.PMA.Logic",
 "DavidTielke.PMA.Data",
 "DavidTielke.PMA.UI",
}

from ns in namespaces

where !allowedPrefixes.Any(ap => ns.FullName.StartsWith(ap))

select new { ns }]]></Query>
  </Group>
  <Group Name="Abhängigkeiten" Active="True" ShownInReport="False">
    <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Keine statischen Klassen</Name>
warnif count > 0 

from t in JustMyCode.Types

where t.IsStatic && !t.IsGeneratedByCompiler

select new { t }]]></Query>
    <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Keine statischen Methoden</Name>
warnif count > 0 

from m in JustMyCode.Methods

where !m.IsPropertyGetter && !m.IsPropertySetter && !m.IsConstructor && !m.IsGeneratedByCompiler

 && m.IsStatic && !m.SimpleName.Contains("Main")


select new { m }]]></Query>
    <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Keine Implementierungsabhängigkeiten</Name>
warnif count > 0 

let blacklist = new string[]
{
  "Program",
  "ServiceCollectionInitializer"
}

let managementClasses = JustMyCode.Types.Where(t => !t.ParentNamespace.FullName.Contains(".DataClasses")
                                                 && !t.IsGeneratedByCompiler
                                                 && t.IsClass
                                                 && !blacklist.Any(blc => t.SimpleName == blc))

from t in managementClasses

let illegalDependencies = t.TypesUsed.Where(tu => !tu.IsThirdParty 
                                               && !tu.IsGeneratedByCompiler 
                                               && !tu.ParentNamespace.FullName.Contains(".DataClasses")
                                               && !tu.IsInterface)

where illegalDependencies.Any()

select new { t, illegalDependencies }]]></Query>
  </Group>
</Queries>